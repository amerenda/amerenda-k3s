apiVersion: v1
kind: ConfigMap
metadata:
  name: homeassistant-scripts
data:
  activate_all_room_scenes.yaml: |
    activate_all_room_scenes:
      alias: "Activate Scene Slot for All Rooms"
      description: "Activates the specified time slot scene for all rooms, respecting override helpers"
      mode: "parallel"
      fields:
        slot:
          description: "Time slot to activate (morning, day, evening, night)"
          selector:
            select:
              options:
                - morning
                - day
                - evening
                - night
      sequence:
        - variables:
            rooms: ['living_room', 'bedroom', 'bathroom', 'hallway', 'kitchen']
            slot_name: "{{ slot }}"
        - repeat:
            for_each: "{{ rooms }}"
            sequence:
              - variables:
                  room: "{{ repeat.item }}"
                  override_select: "input_select.{{ room }}_{{ slot_name }}_scene"
                  override_val: >-
                    {% set val = states(override_select) | default('') %}
                    {{ '' if val in ['unknown', 'unavailable', '', None] else val }}
                  default_scene: "scene.{{ room }}_{{ slot_name }}"
                  scene_to_activate: "{{ override_val if override_val else default_scene }}"
                  scene_exists: >-
                    {{ scene_to_activate in (states.scene | map(attribute='entity_id') | list) }}
                  helper_entity: "input_select.{{ room }}_scene_cycle"
              - if:
                  - condition: template
                    value_template: "{{ scene_exists }}"
                then:
                  - parallel:
                      - service: "scene.turn_on"
                        target:
                          entity_id: "{{ scene_to_activate }}"
                      - if:
                          - condition: template
                            value_template: "{{ helper_entity in (states.input_select | map(attribute='entity_id') | list) }}"
                        then:
                          - service: "input_select.select_option"
                            target:
                              entity_id: "{{ helper_entity }}"
                            data:
                              option: "{{ slot_name }}"
    
  activate_scene_with_helper.yaml: |
    activate_scene_with_helper:
      alias: "Activate Scene and Update Helper"
      mode: "parallel"
      fields:
        scene_entity:
          description: "Scene entity to activate (e.g., scene.bathroom_morning)"
        helper_entity:
          description: "Helper entity to update (e.g., input_select.bathroom_scene_cycle)"
        slot_name:
          description: "Slot name to set in helper (morning, day, evening, night)"
      sequence:
        - parallel:
            - service: "scene.turn_on"
              target:
                entity_id: "{{ scene_entity }}"
            - service: "input_select.select_option"
              target:
                entity_id: "{{ helper_entity }}"
              data:
                option: "{{ slot_name }}"
    
  create_scene_from_lights.yaml: |
    create_scene_from_lights:
      alias: "Create Scene from Current Light States"
      mode: "single"
      fields:
        scene_name:
          description: "Display name for the scene"
          example: "Morning Scene"
        scene_id:
          description: "Scene entity ID (without scene. prefix)"
          example: "bedroom_morning"
        light_entities:
          description: "List of light entity IDs to capture in the scene"
          example: "['light.bedroom_1', 'light.bedroom_2']"
      sequence:
        - variables:
            scene_full_id: "scene.{{ scene_id }}"
            lights_list: >-
              {% if light_entities is string %}
                {{ light_entities.split(',') | map('trim') | list }}
              {% elif light_entities is sequence %}
                {{ light_entities | list }}
              {% else %}
                {{ [] }}
              {% endif %}
        - service: scene.create
          data:
            snapshot_entities: "{{ lights_list }}"
            name: "{{ scene_name }}"
          target:
            entity_id: "{{ scene_full_id }}"
        - service: logbook.log
          data:
            name: "Scene Creator"
            message: "Created scene '{{ scene_full_id }}' ({{ scene_name }}) from {{ lights_list | length }} light(s): {{ lights_list }}"
    
  power_on.yaml: |
    scheduled_light_on:
      alias: "Scheduled Light On (safe)"
      mode: "restart"
      fields:
        custom_schedule_enabled: { required: false }
        custom_s1_start: { required: false }
        custom_s2_start: { required: false }
        custom_s3_start: { required: false }
        custom_s4_start: { required: false }
        transition: { required: false }
        fallback_lights: { required: false }
        timer_mode: { required: false, default: false }
        auto_on: { required: false, default: false }
      sequence:
        - variables:
            default_s1: "06:00:00"
            default_s2: "09:00:00"
            default_s3: "17:00:00"
            default_s4: "22:00:00"
    
            use_custom: >-
              {{ (custom_schedule_enabled is defined) and is_state(custom_schedule_enabled, 'on') }}
    
            s1_str: >-
              {% set v = states(custom_s1_start | default('')) if use_custom else default_s1 %}
              {{ default_s1 if v in ['unknown','unavailable','', None] else v }}
            s2_str: >-
              {% set v = states(custom_s2_start | default('')) if use_custom else default_s2 %}
              {{ default_s2 if v in ['unknown','unavailable','', None] else v }}
            s3_str: >-
              {% set v = states(custom_s3_start | default('')) if use_custom else default_s3 %}
              {{ default_s3 if v in ['unknown','unavailable','', None] else v }}
            s4_str: >-
              {% set v = states(custom_s4_start | default('')) if use_custom else default_s4 %}
              {{ default_s4 if v in ['unknown','unavailable','', None] else v }}
    
            now_ts: "{{ as_timestamp(now()) }}"
            s1: "{{ as_timestamp(today_at(s1_str)) }}"
            s2: "{{ as_timestamp(today_at(s2_str)) }}"
            s3: "{{ as_timestamp(today_at(s3_str)) }}"
            s4: "{{ as_timestamp(today_at(s4_str)) }}"
    
            slot: >-
              {% if now_ts >= s1 and now_ts < s2 %}morning
              {% elif now_ts >= s2 and now_ts < s3 %}day
              {% elif now_ts >= s3 and now_ts < s4 %}evening
              {% else %}night{% endif %}
    
            # Extract entity name from fallback_lights for scene naming
            _fb_entity_raw: "{{ fallback_lights | default('') }}"
            _fb_entity: >-
              {% set fb = _fb_entity_raw %}
              {% if fb is mapping and 'entity_id' in fb %}
                {{ fb.entity_id }}
              {% elif fb is mapping %}
                {{ '' }}
              {% elif fb is string %}
                {{ fb }}
              {% else %}
                {{ '' }}
              {% endif %}
            _entity_name: >-
              {% set entity = _fb_entity %}
              {% if entity is string and entity != '' and entity|length >= 6 and entity[:6] == 'light.' %}
                {{ entity[6:] }}
              {% else %}
                {{ entity }}
              {% endif %}
    
            _override_select: "{{ 'input_select.' ~ _entity_name ~ '_' ~ slot ~ '_scene' }}"
            _override_val: >-
              {% set val = states(_override_select) if _entity_name and _entity_name != '' else '' %}
              {{ '' if val in ['unknown','unavailable','', None] else val }}
    
            default_scene_entity_id: "scene.{{ _entity_name }}_{{ slot }}"
            scene_to_activate: "{{ _override_val if _override_val else default_scene_entity_id }}"
            scene_exists: >-
              {{ scene_to_activate in (states.scene | map(attribute='entity_id') | list) if scene_to_activate else false }}
            
            scene_cycle_helper: >-
              {% if _entity_name and _entity_name != '' %}
                input_select.{{ _entity_name }}_scene_cycle
              {% else %}
                ''
              {% endif %}
    
            all_lights: "{{ states.light | map(attribute='entity_id') | list }}"
            dynamic_fallback: >-
              {% set fb = _fb_entity %}
              {% if fb and fb != '' %}
                {{ fb }}
              {% else %}
                {{ '' }}
              {% endif %}
            
            # Check if lights are on (for timer mode)
            timer_mode_active: "{{ timer_mode | default(false) | bool }}"
            lights_on_check: >-
              {% if timer_mode_active %}
                {% if dynamic_fallback %}
                  {% set fb_entity = dynamic_fallback %}
                  {% if fb_entity is string and fb_entity != '' %}
                    {% set expanded = expand(fb_entity) %}
                    {{ expanded | selectattr('state','eq','on') | list | count > 0 }}
                  {% else %}
                    {{ false }}
                  {% endif %}
                {% else %}
                  {{ false }}
                {% endif %}
              {% else %}
                {{ true }}
              {% endif %}
        
        # Debug logging
        - service: "logbook.log"
          data:
            name: "scheduled_light_on"
            message: >-
              Script called: timer_mode={{ timer_mode | default('NOT_SET') }}, 
              fallback_lights={{ fallback_lights | default('NOT_SET') }}, 
              scene={{ scene_to_activate }}, scene_exists={{ scene_exists }}, 
              lights_on_check={{ lights_on_check }}
        
        - choose:
            - conditions: "{{ scene_exists and lights_on_check | bool }}"
              sequence:
                - service: "logbook.log"
                  data:
                    name: "scheduled_light_on"
                    message: >-
                      ACTIVATING SCENE: {{ scene_to_activate }} 
                      (scene_exists={{ scene_exists }}, lights_on_check={{ lights_on_check }})
                - parallel:
                    - service: "scene.turn_on"
                      data:
                        transition: "{{ transition | default(0) }}"
                      target:
                        entity_id: "{{ scene_to_activate }}"
                    - if:
                        - condition: template
                          value_template: "{{ scene_cycle_helper != '' }}"
                      then:
                        - service: "input_select.select_option"
                          target:
                            entity_id: "{{ scene_cycle_helper }}"
                          data:
                            option: "{{ slot }}"
                - service: "logbook.log"
                  data:
                    name: "scheduled_light_on"
                    message: >-
                      Scene {{ scene_to_activate }} activated successfully
            - conditions: "{{ scene_exists and not lights_on_check | bool }}"
              sequence:
                - choose:
                    - conditions: "{{ timer_mode_active and (auto_on | default(false) | bool) }}"
                      sequence:
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: >-
                              Lights are off but auto_on=True - turning on lights first, then applying scene
                              (fallback_lights={{ dynamic_fallback }})
                        - service: "light.turn_on"
                          target:
                            entity_id: "{{ dynamic_fallback }}"
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: "Lights turned on, now applying scene {{ scene_to_activate }}"
                        - service: "scene.turn_on"
                          data:
                            transition: "{{ transition | default(0) }}"
                          target:
                            entity_id: "{{ scene_to_activate }}"
                        - if:
                            - condition: template
                              value_template: "{{ scene_cycle_helper != '' }}"
                          then:
                            - service: "input_select.select_option"
                              target:
                                entity_id: "{{ scene_cycle_helper }}"
                              data:
                                option: "{{ slot }}"
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: >-
                              Scene {{ scene_to_activate }} activated successfully (auto_on enabled)
                    - conditions: []
                      sequence:
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: >-
                              SKIPPED: Scene '{{ scene_to_activate }}' - lights are off 
                              (lights_on_check={{ lights_on_check }}, auto_on={{ auto_on | default(false) }})
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: "Timer mode: Scene '{{ scene_to_activate }}' skipped - lights are off and auto_on is disabled"
          default:
            - service: "logbook.log"
              data:
                name: "scheduled_light_on"
                message: >-
                  Scene '{{ scene_to_activate }}' does NOT exist 
                  (scene_exists={{ scene_exists }})
            - choose:
                - conditions: "{{ timer_mode_active }}"
                  sequence:
                    - service: "logbook.log"
                      data:
                        name: "scheduled_light_on"
                        message: >-
                          Timer mode: Scene missing and timer mode enabled - no action taken
                    - service: "logbook.log"
                      data:
                        name: "scheduled_light_on"
                        message: "Timer mode: Scene '{{ scene_to_activate }}' missing and timer mode enabled - no action taken"
                - conditions: []
                  sequence:
                    - choose:
                        - conditions: "{{ dynamic_fallback != '' }}"
                          sequence:
                            - service: "light.turn_on"
                              target:
                                entity_id: "{{ dynamic_fallback }}"
                            - service: "logbook.log"
                              data:
                                name: "scheduled_light_on"
                                message: "Scene '{{ scene_to_activate }}' missing; used '{{ dynamic_fallback }}'"
                                entity_id: "{{ dynamic_fallback }}"
                      default:
                        - service: "logbook.log"
                          data:
                            name: "scheduled_light_on"
                            message: "Scene '{{ scene_to_activate }}' missing; no fallback light entity available"
  room_toggle.yaml: |
    room_toggle:
      alias: "Room Toggle (smart with debug)"
      mode: "parallel"
      fields:
        target_lights:
          description: "Entity or group to control (entity_id, list, or target)"
      sequence:
        - variables:
            _ids: >-
              {% set tl = target_lights | default('') %}
              {% if tl is mapping and 'entity_id' in tl %}
                {{ tl.entity_id }}
              {% else %}
                {{ tl }}
              {% endif %}
            id_list: >-
              {% if _ids is string and _ids != '' %}
                {{ [_ids] }}
              {% elif _ids is sequence and _ids is not string %}
                {{ _ids | list }}
              {% else %}
                {{ [] }}
              {% endif %}
    
            # Check group state directly (for Hue groups that don't expand)
            group_on: >-
              {% if id_list | length == 1 %}
                {{ is_state(id_list[0], 'on') }}
              {% else %}
                {{ false }}
              {% endif %}
    
            # Check member entities via expand (for normal groups)
            expanded: "{{ expand(id_list) }}"
            members_on: "{{ expanded | selectattr('state','eq','on') | list | count > 0 }}"
    
            # Check member entities via state_attr (for Hue groups)
            attr_members: >-
              {% if id_list | length == 1 %}
                {{ state_attr(id_list[0], 'entity_id') | default([]) }}
              {% else %}
                {{ [] }}
              {% endif %}
            attr_members_on: "{{ expand(attr_members) | selectattr('state','eq','on') | list | count > 0 }}"
    
            # Any method indicates lights are on
            any_on: "{{ group_on or members_on or attr_members_on }}"
    
        # DEBUG: Log what we detected
        - service: "logbook.log"
          data:
            name: "room_toggle DEBUG"
            message: >-
              id_list={{ id_list }}, group_on={{ group_on }},
              members_on={{ members_on }}, attr_members_on={{ attr_members_on }},
              any_on={{ any_on }}
        - choose:
            - conditions: "{{ any_on }}"
              sequence:
                - service: "logbook.log"
                  data:
                    name: "room_toggle"
                    message: "Turning OFF {{ id_list }}"
                - service: "light.turn_off"
                  target:
                    entity_id: "{{ id_list }}"
          default:
            - service: "logbook.log"
              data:
                name: "room_toggle"
                message: "Turning ON {{ id_list[0] if id_list|length>0 else 'target_lights' }} via scheduled_light_on"
            - service: "script.scheduled_light_on"
              data:
                fallback_lights: "{{ id_list[0] if id_list|length>0 else '' }}"
  smooth_transition.yaml: |
    smooth_transition:
      alias: "Smooth Transition to Next Scene"
      description: "Gradually transitions lights from current state to next scheduled scene over a configurable time window"
      mode: "restart"
      fields:
        room:
          description: "Room key (e.g., bedroom, living_room)"
          selector:
            text: {}
        target_slot:
          description: "Optional target slot (morning/day/evening/night). If provided, uses this as the next scene. If not provided, calculates from schedule."
          required: false
          selector:
            select:
              options:
                - morning
                - day
                - evening
                - night
        transition_minutes:
          description: "Transition duration in minutes"
          required: false
          default: 15
          selector:
            number:
              min: 1
              max: 60
              unit_of_measurement: "min"
        auto_on:
          description: "If true, turns on lights if they're off before transitioning"
          required: false
          default: false
          selector:
            boolean: {}
        custom_schedule_enabled:
          description: "Optional custom schedule enabled boolean"
          required: false
          selector:
            entity:
              domain: input_boolean
        custom_s1_start:
          description: "Optional morning start (time-only)"
          required: false
          selector:
            entity:
              domain: input_datetime
        custom_s2_start:
          description: "Optional day start (time-only)"
          required: false
          selector:
            entity:
              domain: input_datetime
        custom_s3_start:
          description: "Optional evening start (time-only)"
          required: false
          selector:
            entity:
              domain: input_datetime
        custom_s4_start:
          description: "Optional night start (time-only)"
          required: false
          selector:
            entity:
              domain: input_datetime
      sequence:
        - variables:
            default_s1: "06:00:00"
            default_s2: "09:00:00"
            default_s3: "17:00:00"
            default_s4: "22:00:00"
    
            # Check per-time-window custom times
            morning_custom: >-
              {% set helper = 'input_boolean.' ~ room ~ '_morning_custom_time' %}
              {% set state_val = states(helper) %}
              {% if state_val not in ['unknown', 'unavailable', None, ''] %}
                {{ is_state(helper, 'on') }}
              {% elif custom_schedule_enabled is defined and custom_schedule_enabled != '' %}
                {{ is_state(custom_schedule_enabled, 'on') }}
              {% else %}
                {{ false }}
              {% endif %}
            day_custom: >-
              {% set helper = 'input_boolean.' ~ room ~ '_day_custom_time' %}
              {% set state_val = states(helper) %}
              {% if state_val not in ['unknown', 'unavailable', None, ''] %}
                {{ is_state(helper, 'on') }}
              {% elif custom_schedule_enabled is defined and custom_schedule_enabled != '' %}
                {{ is_state(custom_schedule_enabled, 'on') }}
              {% else %}
                {{ false }}
              {% endif %}
            evening_custom: >-
              {% set helper = 'input_boolean.' ~ room ~ '_evening_custom_time' %}
              {% set state_val = states(helper) %}
              {% if state_val not in ['unknown', 'unavailable', None, ''] %}
                {{ is_state(helper, 'on') }}
              {% elif custom_schedule_enabled is defined and custom_schedule_enabled != '' %}
                {{ is_state(custom_schedule_enabled, 'on') }}
              {% else %}
                {{ false }}
              {% endif %}
            night_custom: >-
              {% set helper = 'input_boolean.' ~ room ~ '_night_custom_time' %}
              {% set state_val = states(helper) %}
              {% if state_val not in ['unknown', 'unavailable', None, ''] %}
                {{ is_state(helper, 'on') }}
              {% elif custom_schedule_enabled is defined and custom_schedule_enabled != '' %}
                {{ is_state(custom_schedule_enabled, 'on') }}
              {% else %}
                {{ false }}
              {% endif %}
    
            # Check if separate weekday/weekend times are enabled
            morning_separate: >-
              {% set helper = 'input_boolean.' ~ room ~ '_morning_separate_weekday_weekend' %}
              {{ is_state(helper, 'on') if states(helper) not in ['unknown', 'unavailable'] else false }}
            day_separate: >-
              {% set helper = 'input_boolean.' ~ room ~ '_day_separate_weekday_weekend' %}
              {{ is_state(helper, 'on') if states(helper) not in ['unknown', 'unavailable'] else false }}
            evening_separate: >-
              {% set helper = 'input_boolean.' ~ room ~ '_evening_separate_weekday_weekend' %}
              {{ is_state(helper, 'on') if states(helper) not in ['unknown', 'unavailable'] else false }}
            night_separate: >-
              {% set helper = 'input_boolean.' ~ room ~ '_night_separate_weekday_weekend' %}
              {{ is_state(helper, 'on') if states(helper) not in ['unknown', 'unavailable'] else false }}
            
            # Check if today is a weekday (Mon-Fri) or weekend (Sat-Sun)
            is_weekday: >-
              {% set day = now().strftime('%A').lower() %}
              {{ day in ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'] }}
    
            # Get schedule times
            s1_str: >-
              {% if morning_custom %}
                {% if morning_separate %}
                  {% if is_weekday %}
                    {% set v = states('input_datetime.' ~ room ~ '_s1_weekday_start') %}
                  {% else %}
                    {% set v = states('input_datetime.' ~ room ~ '_s1_weekend_start') %}
                  {% endif %}
                {% else %}
                  {% set v = states('input_datetime.' ~ room ~ '_s1_start') %}
                {% endif %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s1 }}{% else %}{{ v }}{% endif %}
              {% elif custom_s1_start is defined and custom_s1_start != '' %}
                {% set v = states(custom_s1_start) %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s1 }}{% else %}{{ v }}{% endif %}
              {% else %}
                {{ default_s1 }}
              {% endif %}
            s2_str: >-
              {% if day_custom %}
                {% if day_separate %}
                  {% if is_weekday %}
                    {% set v = states('input_datetime.' ~ room ~ '_s2_weekday_start') %}
                  {% else %}
                    {% set v = states('input_datetime.' ~ room ~ '_s2_weekend_start') %}
                  {% endif %}
                {% else %}
                  {% set v = states('input_datetime.' ~ room ~ '_s2_start') %}
                {% endif %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s2 }}{% else %}{{ v }}{% endif %}
              {% elif custom_s2_start is defined and custom_s2_start != '' %}
                {% set v = states(custom_s2_start) %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s2 }}{% else %}{{ v }}{% endif %}
              {% else %}
                {{ default_s2 }}
              {% endif %}
            s3_str: >-
              {% if evening_custom %}
                {% if evening_separate %}
                  {% if is_weekday %}
                    {% set v = states('input_datetime.' ~ room ~ '_s3_weekday_start') %}
                  {% else %}
                    {% set v = states('input_datetime.' ~ room ~ '_s3_weekend_start') %}
                  {% endif %}
                {% else %}
                  {% set v = states('input_datetime.' ~ room ~ '_s3_start') %}
                {% endif %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s3 }}{% else %}{{ v }}{% endif %}
              {% elif custom_s3_start is defined and custom_s3_start != '' %}
                {% set v = states(custom_s3_start) %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s3 }}{% else %}{{ v }}{% endif %}
              {% else %}
                {{ default_s3 }}
              {% endif %}
            s4_str: >-
              {% if night_custom %}
                {% if night_separate %}
                  {% if is_weekday %}
                    {% set v = states('input_datetime.' ~ room ~ '_s4_weekday_start') %}
                  {% else %}
                    {% set v = states('input_datetime.' ~ room ~ '_s4_weekend_start') %}
                  {% endif %}
                {% else %}
                  {% set v = states('input_datetime.' ~ room ~ '_s4_start') %}
                {% endif %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s4 }}{% else %}{{ v }}{% endif %}
              {% elif custom_s4_start is defined and custom_s4_start != '' %}
                {% set v = states(custom_s4_start) %}
                {% if v in ['unknown','unavailable',''] %}{{ default_s4 }}{% else %}{{ v }}{% endif %}
              {% else %}
                {{ default_s4 }}
              {% endif %}
    
            now_ts: "{{ as_timestamp(now()) }}"
            s1: "{{ as_timestamp(today_at(s1_str)) }}"
            s2: "{{ as_timestamp(today_at(s2_str)) }}"
            s3: "{{ as_timestamp(today_at(s3_str)) }}"
            s4: "{{ as_timestamp(today_at(s4_str)) }}"
    
            # Determine current and next slots
            # If target_slot is provided, use it as next slot and calculate previous slot
            # Otherwise, calculate both from time
            slot_order: ['morning', 'day', 'evening', 'night']
            next_slot: >-
              {% if target_slot is defined and target_slot != '' and target_slot in slot_order %}
                {{ target_slot }}
              {% else %}
                {% if now_ts >= s1 and now_ts < s2 %}day
                {% elif now_ts >= s2 and now_ts < s3 %}evening
                {% elif now_ts >= s3 and now_ts < s4 %}night
                {% else %}morning{% endif %}
              {% endif %}
            current_slot: >-
              {% if target_slot is defined and target_slot != '' and target_slot in slot_order %}
                {% set idx = slot_order.index(target_slot) %}
                {{ slot_order[(idx - 1) % slot_order|length] }}
              {% else %}
                {% if now_ts >= s1 and now_ts < s2 %}morning
                {% elif now_ts >= s2 and now_ts < s3 %}day
                {% elif now_ts >= s3 and now_ts < s4 %}evening
                {% else %}night{% endif %}
              {% endif %}
    
            # Get scene entity IDs with override support
            current_override_select: "input_select.{{ room }}_{{ current_slot }}_scene"
            current_override_val: >-
              {% set val = states(current_override_select) %}
              {{ '' if val in ['unknown','unavailable','', None] else val }}
            current_scene_entity_id: "scene.{{ room }}_{{ current_slot }}"
            current_scene: "{{ current_override_val if current_override_val else current_scene_entity_id }}"
            current_scene_exists: >-
              {{ current_scene in (states.scene | map(attribute='entity_id') | list) if current_scene else false }}
    
            next_override_select: "input_select.{{ room }}_{{ next_slot }}_scene"
            next_override_val: >-
              {% set val = states(next_override_select) %}
              {{ '' if val in ['unknown','unavailable','', None] else val }}
            next_scene_entity_id: "scene.{{ room }}_{{ next_slot }}"
            next_scene: "{{ next_override_val if next_override_val else next_scene_entity_id }}"
            next_scene_exists: >-
              {{ next_scene in (states.scene | map(attribute='entity_id') | list) if next_scene else false }}
    
            # Transition parameters
            transition_seconds: "{{ (transition_minutes | default(15) | int) * 60 }}"
            brightness_step_seconds: 30
            brightness_steps: "{{ (transition_seconds | int) / brightness_step_seconds | int }}"
    
        # Debug logging
        - service: "logbook.log"
          data:
            name: "smooth_transition"
            message: >-
              Starting transition: room={{ room }}, current_scene={{ current_scene }}, 
              next_scene={{ next_scene }}, transition_minutes={{ transition_minutes | default(15) }}
    
        # Check if scenes exist
        - choose:
            - conditions: "{{ not current_scene_exists }}"
              sequence:
                - service: "logbook.log"
                  data:
                    name: "smooth_transition"
                    message: >-
                      ERROR: Current scene '{{ current_scene }}' does not exist. Cannot transition.
            - conditions: "{{ not next_scene_exists }}"
              sequence:
                - service: "logbook.log"
                  data:
                    name: "smooth_transition"
                    message: >-
                      ERROR: Next scene '{{ next_scene }}' does not exist. Cannot transition.
            - conditions: "{{ current_scene_exists and next_scene_exists }}"
              sequence:
                # Get lights from next scene
                - variables:
                    next_scene_attrs: "{{ state_attr(next_scene, 'attributes') }}"
                    next_scene_states: "{{ next_scene_attrs.states if next_scene_attrs else {} }}"
                    # Get list of light entities from scene
                    scene_lights: >-
                      {% set lights = [] %}
                      {% for entity_id, state_data in next_scene_states.items() %}
                        {% if entity_id.startswith('light.') %}
                          {% set _ = lights.append(entity_id) %}
                        {% endif %}
                      {% endfor %}
                      {{ lights }}
    
                # Check if lights are on
                - variables:
                    lights_on: >-
                      {% set on_count = 0 %}
                      {% for light_id in scene_lights %}
                        {% if is_state(light_id, 'on') %}
                          {% set on_count = on_count + 1 %}
                        {% endif %}
                      {% endfor %}
                      {{ on_count > 0 }}
    
                # Handle lights that are off
                - choose:
                    - conditions: "{{ not lights_on and (auto_on | default(false) | bool) }}"
                      sequence:
                        - service: "logbook.log"
                          data:
                            name: "smooth_transition"
                            message: "Lights are off but auto_on=True - turning on lights first"
                        - service: "light.turn_on"
                          target:
                            entity_id: "{{ scene_lights }}"
                        - delay:
                            seconds: 2
                    - conditions: "{{ not lights_on and not (auto_on | default(false) | bool) }}"
                      sequence:
                        - service: "logbook.log"
                          data:
                            name: "smooth_transition"
                            message: "SKIPPED: Lights are off and auto_on is false. Cannot transition."
                - choose:
                    - conditions: "{{ lights_on or (auto_on | default(false) | bool) }}"
                      sequence:
                        # Read current and target states for each light
                        - variables:
                            light_transitions: >-
                              {% set transitions = [] %}
                              {% for light_id in scene_lights %}
                                {% set current_state = states(light_id) %}
                                {% set light_data = {
                                  'entity_id': light_id,
                                  'current_brightness': state_attr(light_id, 'brightness') | default(0) | int,
                                  'current_color_temp': state_attr(light_id, 'color_temp'),
                                  'current_rgb_color': state_attr(light_id, 'rgb_color'),
                                  'current_hs_color': state_attr(light_id, 'hs_color'),
                                  'target_brightness': 0,
                                  'target_color_temp': None,
                                  'target_rgb_color': None,
                                  'target_hs_color': None,
                                  'supports_color_temp': state_attr(light_id, 'supported_color_modes') | default([]) | select('eq', 'color_temp') | list | count > 0,
                                  'supports_rgb': state_attr(light_id, 'supported_color_modes') | default([]) | select('eq', 'rgb') | list | count > 0,
                                  'supports_hs': state_attr(light_id, 'supported_color_modes') | default([]) | select('eq', 'hs') | list | count > 0
                                } %}
                                {% if light_id in next_scene_states %}
                                  {% set target_state = next_scene_states[light_id] %}
                                  {% if target_state is mapping and 'attributes' in target_state %}
                                    {% set target_attrs = target_state.attributes %}
                                    {% set _ = light_data.update({
                                      'target_brightness': target_attrs.brightness | default(0) | int,
                                      'target_color_temp': target_attrs.color_temp if 'color_temp' in target_attrs else None,
                                      'target_rgb_color': target_attrs.rgb_color if 'rgb_color' in target_attrs else None,
                                      'target_hs_color': target_attrs.hs_color if 'hs_color' in target_attrs else None
                                    }) %}
                                  {% endif %}
                                {% endif %}
                                {% set _ = transitions.append(light_data) %}
                              {% endfor %}
                              {{ transitions }}
    
                        # Apply color/color_temp transition (using Home Assistant's built-in transition)
                        - repeat:
                            for_each: "{{ light_transitions }}"
                            sequence:
                              - variables:
                                  light: "{{ repeat.item }}"
                                  has_color_change: >-
                                    {% set has_ct = light.target_color_temp is not none and light.current_color_temp != light.target_color_temp %}
                                    {% set has_rgb = light.target_rgb_color is not none and light.current_rgb_color != light.target_rgb_color %}
                                    {% set has_hs = light.target_hs_color is not none and light.current_hs_color != light.target_hs_color %}
                                    {{ has_ct or has_rgb or has_hs }}
                              - choose:
                                  - conditions: "{{ has_color_change }}"
                                    sequence:
                                      - service: "light.turn_on"
                                        target:
                                          entity_id: "{{ light.entity_id }}"
                                        data:
                                          transition: "{{ transition_seconds | int }}"
                                          {% if light.supports_color_temp and light.target_color_temp is not none %}
                                          color_temp: "{{ light.target_color_temp }}"
                                          {% endif %}
                                          {% if light.supports_rgb and light.target_rgb_color is not none %}
                                          rgb_color: "{{ light.target_rgb_color }}"
                                          {% elif light.supports_hs and light.target_hs_color is not none %}
                                          hs_color: "{{ light.target_hs_color }}"
                                          {% endif %}
    
                        # Apply brightness transition incrementally
                        - repeat:
                            count: "{{ brightness_steps | int }}"
                            sequence:
                              - variables:
                                  step: "{{ repeat.index }}"
                                  step_progress: "{{ (step / brightness_steps | int) | float }}"
                              - repeat:
                                  for_each: "{{ light_transitions }}"
                                  sequence:
                                    - variables:
                                        light: "{{ repeat.item }}"
                                        current_br: "{{ light.current_brightness }}"
                                        target_br: "{{ light.target_brightness }}"
                                        brightness_delta: "{{ target_br - current_br }}"
                                        new_brightness: >-
                                          {% if step == brightness_steps | int %}
                                            {{ target_br }}
                                          {% else %}
                                            {% set calculated = (current_br + (brightness_delta * step_progress)) | int %}
                                            {{ [0, 255, calculated] | sort | list[1] }}
                                          {% endif %}
                                    - service: "light.turn_on"
                                      target:
                                        entity_id: "{{ light.entity_id }}"
                                      data:
                                        brightness: "{{ new_brightness }}"
                              - delay:
                                  seconds: "{{ brightness_step_seconds }}"
    
                        # Final step: ensure all lights are at target brightness
                        - repeat:
                            for_each: "{{ light_transitions }}"
                            sequence:
                              - service: "light.turn_on"
                                target:
                                  entity_id: "{{ repeat.item.entity_id }}"
                                data:
                                  brightness: "{{ repeat.item.target_brightness }}"
    
                        # Update scene cycle helper
                        - variables:
                            scene_cycle_helper: "input_select.{{ room }}_scene_cycle"
                        - if:
                            - condition: template
                              value_template: "{{ scene_cycle_helper in (states.input_select | map(attribute='entity_id') | list) }}"
                          then:
                            - service: "input_select.select_option"
                              target:
                                entity_id: "{{ scene_cycle_helper }}"
                              data:
                                option: "{{ next_slot }}"
    
                        - service: "logbook.log"
                          data:
                            name: "smooth_transition"
                            message: >-
                              Transition complete: {{ room }} from {{ current_slot }} to {{ next_slot }} 
                              over {{ transition_minutes | default(15) }} minutes
    
  toggle_weekdays.yaml: |
    toggle_weekdays:
      alias: "Toggle Weekdays for Room Slot"
      description: "Toggles all weekdays (Monday-Friday) for a specific room and time slot"
      mode: "single"
      fields:
        room:
          description: "Room key (e.g., bedroom, living_room)"
          selector:
            text: {}
        slot:
          description: "Time slot (morning, day, evening, night)"
          selector:
            select:
              options:
                - morning
                - day
                - evening
                - night
      sequence:
        - variables:
            room: "{{ room }}"
            slot: "{{ slot }}"
            monday_helper: "input_boolean.{{ room }}_{{ slot }}_monday"
            tuesday_helper: "input_boolean.{{ room }}_{{ slot }}_tuesday"
            wednesday_helper: "input_boolean.{{ room }}_{{ slot }}_wednesday"
            thursday_helper: "input_boolean.{{ room }}_{{ slot }}_thursday"
            friday_helper: "input_boolean.{{ room }}_{{ slot }}_friday"
            # Check current state - if all are on, turn off; otherwise turn on
            monday_state: "{{ states(monday_helper) }}"
            tuesday_state: "{{ states(tuesday_helper) }}"
            wednesday_state: "{{ states(wednesday_helper) }}"
            thursday_state: "{{ states(thursday_helper) }}"
            friday_state: "{{ states(friday_helper) }}"
            all_on: >-
              {{ monday_state == 'on' and tuesday_state == 'on' and 
                 wednesday_state == 'on' and thursday_state == 'on' and 
                 friday_state == 'on' }}
            target_state: "{{ 'off' if all_on else 'on' }}"
        - parallel:
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ monday_helper }}"
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ tuesday_helper }}"
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ wednesday_helper }}"
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ thursday_helper }}"
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ friday_helper }}"
    
  toggle_weekends.yaml: |
    toggle_weekends:
      alias: "Toggle Weekends for Room Slot"
      description: "Toggles all weekends (Saturday-Sunday) for a specific room and time slot"
      mode: "single"
      fields:
        room:
          description: "Room key (e.g., bedroom, living_room)"
          selector:
            text: {}
        slot:
          description: "Time slot (morning, day, evening, night)"
          selector:
            select:
              options:
                - morning
                - day
                - evening
                - night
      sequence:
        - variables:
            room: "{{ room }}"
            slot: "{{ slot }}"
            saturday_helper: "input_boolean.{{ room }}_{{ slot }}_saturday"
            sunday_helper: "input_boolean.{{ room }}_{{ slot }}_sunday"
            # Check current state - if all are on, turn off; otherwise turn on
            saturday_state: "{{ states(saturday_helper) }}"
            sunday_state: "{{ states(sunday_helper) }}"
            all_on: >-
              {{ saturday_state == 'on' and sunday_state == 'on' }}
            target_state: "{{ 'off' if all_on else 'on' }}"
        - parallel:
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ saturday_helper }}"
            - service: "input_boolean.turn_{{ target_state }}"
              target:
                entity_id: "{{ sunday_helper }}"
    
